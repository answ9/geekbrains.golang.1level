1. Проанализируйте задания предыдущих уроков.
a) В каких случаях необходима была явная передача указателя в качестве входных параметров и возвращаемых результатов или в качестве приёмника в методах?
	fmt.Scanf("%d\n", &numPoint)
	fmt.Scan(&numPoint)
	fmt.Println(&answer) 

b) В каких случаях мы фактически имеем дело с указателями при передаче параметров, хотя явно их не указываем?
	fmt.Scanf("%d\n", &numPoint)
	fmt.Scan(&numPoint)
	fmt.Println(&answer) 
	
	композитные литералы для массивов могут дополнены префиксом в виде оператора адреса (&) для создания нового указателя на массив. 
	Массивы также предоставляют автоматическое разыменование, как показано в следующем примере.
		superpowers := &[3]string{"flight", "invisibility", "super strength"}
		fmt.Println(superpowers[0]) // Выводит: flight
		fmt.Println(superpowers[1:2]) // Выводит: [invisibility]

2. Для арифметического умножения и разыменования указателей в Go используется один и тот же символ — оператор (*). 
Как вы думаете, как компилятор Go понимает, в каких случаях в выражении имеется в виду умножение, а в каких — разыменование указателя?

Оператор deferencing * является унарным оператором, поэтому в тривиальных случаях компилятор будет применять неявное правило. например
	int a;
	int *ptr = &a;
	*ptr = 5;

Оператор умножения * - это бинарный оператор, поэтому в тривиальных случаях компилятор будет применять умножение при условии, что операнды его поддерживают, например:
	int a;
	int b;
	int c = a*b;

Для более сложных операций вам может потребоваться помочь компилятору понять, что вы имеете в виду, используя круглые скобки, если операторы приоритета недостаточно, например:
	int a = 1;
	int b[2] = {2,3};
	int *aPtr = &a;
	int *bPtr = b;
	int c = *aPtr * *(bPtr+1);